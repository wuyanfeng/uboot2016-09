/*
 * (C) Copyright 2002
 * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
 * Marius Groeger <mgroeger@sysgo.de>
 *
 * (C) Copyright 2002, 2010
 * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
 *
 * SPDX-License-Identifier:	GPL-2.0+
 */

#include <common.h>
#include <asm/io.h>
#include <asm/arch/s3c24x0_cpu.h>
#include <netdev.h>
#include <lcd.h>
#include <generated/version_autogenerated.h>

DECLARE_GLOBAL_DATA_PTR;

#define FCLK_SPEED 1

#if (FCLK_SPEED == 0)		/* Fout = 203MHz, Fin = 12MHz for Audio */
#define M_MDIV	0xC3
#define M_PDIV	0x4
#define M_SDIV	0x1
#elif (FCLK_SPEED == 1)		/* Fout = 271.5MHz */
#define M_MDIV	0xA1
#define M_PDIV	0x3
#define M_SDIV	0x2
#endif

#define USB_CLOCK 1

#if (USB_CLOCK == 0)
#define U_M_MDIV	0xA1
#define U_M_PDIV	0x3
#define U_M_SDIV	0x1
#elif (USB_CLOCK == 1)
#define U_M_MDIV	0x38
#define U_M_PDIV	0x2
#define U_M_SDIV	0x2
#endif

#ifdef CONFIG_LCD

/*lcd register bits define*/
#define BPPMODE_TFT_1BPP	(0x8 << 1)
#define BPPMODE_TFT_2BPP	(0X9 << 1)
#define BPPMODE_TFT_4BPP	(0xA << 1)
#define BPPMODE_TFT_8BPP	(0XB << 1)
#define BPPMODE_TFT_16BPP	(0XC << 1)
#define BPPMODE_TFT_24BPP	(0XD << 1)

#define ENVID				0x01
#define PNRMODE_TFT			(0X03 << 5)
#define MMODE				(1 << 7)
#define VCLKVAL				(4<<8)

#define VBPD 				(1 << 24)
#define VFPD				(1 << 6)
#define VSPW				(9)
#define LINEVAL				((272 - 1) << 14)

#define HBPD				(1 << 19)
#define HOZVAL				((480-1) << 8)
#define HFPD				(1<<0)

#define HSPW				40
#define BPP24BL				(1<<12)
#define FRM565				(1<<11)
#define INVVCLK_RISING		(1<<10)
#define INVVLINE_INVERTED 	(1<<9)
#define INVVFRAME_INVERTED	(1<<8)
#define INVPWREN			(1<<5)
#define INVVD 				(1<<7)
#define HWSWP				(1<<0)

#define PWREN				(1<<3)
#define ENLEND				(1<<2)
#define TAPLEN				(1<<24)

#define PAGEWIDTH			((480 * 4 / 2) << 0)
#define OFFSIZE				(0<<11)
#define LCDBANK 			(((unsigned int)lcdbase>>22)<<21)
#define LCDBASEU			(((unsigned int)lcdbase >>1))
#define LCDBASEL			(LCDBASEU + (PAGEWIDTH + (OFFSIZE>>11))*272)
				

vidinfo_t panel_info = {
	.vl_col =		480,
	.vl_row =		272,
	.vl_rot = 		0,
	.vl_bpix = 		5

};

#if LCD_BPP == LCD_COLOR8
void lcd_setcolreg(ushort regno, ushort red, ushort green, ushort blue)
{
	struct s3c24x0_lcd *const lcd_reg = s3c24x0_get_base_lcd();
	writel(TAPLEN | (blue) | (green << 8) | (red << 16),&lcd_reg->tpal);
}
#endif

void lcd_ctrl_init(void *lcdbase)
{
	struct s3c24x0_lcd *const lcd_reg = s3c24x0_get_base_lcd();
	struct s3c24x0_clock_power * const clk_power = s3c24x0_get_base_clock_power();

	debug("LCD buffer base %8x\n",(unsigned int)lcdbase);
	/*Enable lcd hclk CLOCK*/
	writel(readl(&clk_power-> clkcon) | (1 << 5),&clk_power->clkcon); 
	/*caculate vclk frequence*/
	/*set clkval mmode = 1 PNRMODE = 11 bppmode = 1101 ENVID = 1*/
	writel(VCLKVAL | PNRMODE_TFT | BPPMODE_TFT_24BPP,&lcd_reg->lcdcon1);
	writel(VBPD | VFPD | VSPW | LINEVAL,&lcd_reg->lcdcon2);
	writel(HBPD | HOZVAL | HFPD,&lcd_reg->lcdcon3);
	writel(HSPW,&lcd_reg->lcdcon4);
	writel((FRM565 | INVVLINE_INVERTED |  INVVFRAME_INVERTED  | INVPWREN)& ~BPP24BL,&lcd_reg->lcdcon5);
	debug("lcdaddr1%8x",(unsigned int)lcdbase>>1);
	writel(LCDBANK  | LCDBASEU,&lcd_reg->lcdsaddr1);
	writel(LCDBASEL,&lcd_reg->lcdsaddr2);
	writel(OFFSIZE | PAGEWIDTH, &lcd_reg->lcdsaddr3);
	writel(0x00000000,&lcd_reg->lpcsel);
	/*disable temp pallte*/
	writel(0X00000000,&lcd_reg->tpal);
	/*disable lcd interrupt*/
	writel(0xffffffff,&lcd_reg->lcdintmsk);	

}

void lcd_enable(void)
{
	struct s3c24x0_lcd *const lcd_reg = s3c24x0_get_base_lcd();
	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();

	writel(readl(&lcd_reg->lcdcon5 )| PWREN,&lcd_reg->lcdcon5);
	writel(readl(&lcd_reg->lcdcon1) | ENVID,&lcd_reg->lcdcon1);
	writel(readl(&gpio->gpbdat) | (1<<0),&gpio->gpbdat);
}

void lcd_show_board_info(void)
{
	char temp[32];

	lcd_printf ("%s\n", U_BOOT_VERSION);
	lcd_printf ("(C) 2017 JZ2440 Corp\n");
	lcd_printf ("%s CPU at %s MHz\n",
		JZ2440_CPU_NAME,
		strmhz(temp, get_FCLK()));

}

#endif

static inline void pll_delay(unsigned long loops)
{
	__asm__ volatile ("1:\n"
	  "subs %0, %1, #1\n"
	  "bne 1b" : "=r" (loops) : "0" (loops));
}

/*
 * Miscellaneous platform dependent initialisations
 */



int board_early_init_f(void)
{
	struct s3c24x0_clock_power * const clk_power =
					s3c24x0_get_base_clock_power();
	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();

	/* to reduce PLL lock time, adjust the LOCKTIME register */
	writel(0xFFFFFF, &clk_power->locktime);

	/* configure MPLL */
	writel((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV,
	       &clk_power->mpllcon);

	/* some delay between MPLL and UPLL */
	pll_delay(4000);

	/* configure UPLL */
	writel((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV,
	       &clk_power->upllcon);

	/* some delay between MPLL and UPLL */
	pll_delay(8000);

	/* set up the I/O ports */
	writel(0x007FFFFF, &gpio->gpacon);
	writel(0x00044555, &gpio->gpbcon);
	writel(0x000007FF, &gpio->gpbup);
	writel(0xAAAAAAAA, &gpio->gpccon);
	writel(0x0000FFFF, &gpio->gpcup);
	writel(0xAAAAAAAA, &gpio->gpdcon);
	writel(0x0000FFFF, &gpio->gpdup);
	writel(0xAAAAAAAA, &gpio->gpecon);
	writel(0x0000FFFF, &gpio->gpeup);
	writel(0x00005522, &gpio->gpfcon);
	writel(0x000000FF, &gpio->gpfup);
	writel(0x00800080, &gpio->gpgcon);
	writel(0x0000FFFF, &gpio->gpgup);
	writel(0x002AFAAA, &gpio->gphcon);
	writel(0x000007FF, &gpio->gphup);
	writel(readl(&gpio->gpfdat) | 0x00000070, &gpio->gpfdat);
	writel(readl(&gpio->gpbdat) & ~(1<<0),&gpio->gpbdat);
	return 0;
}

int board_init(void)
{
	/* arch number of JZ2440-Board */
	gd->bd->bi_arch_number = MACH_TYPE_JZ2440;

	/* adress of boot parameters */
	gd->bd->bi_boot_params = CONFIG_BOOT_PARAMETER_ADDRESS;



	return 0;
}

int dram_init(void)
{
	/* dram_init must store complete ramsize in gd->ram_size */
	gd->ram_size = PHYS_SDRAM_1_SIZE;	
	return 0;
}

#ifdef CONFIG_CMD_NET
int board_eth_init(bd_t *bis)
{
	int rc = 0;
#ifdef CONFIG_CS8900
	rc = cs8900_initialize(0, CONFIG_CS8900_BASE);
#endif
#ifdef CONFIG_DM9000
	rc = dm9000_initialize(bis);
#endif
	return rc;
}
#endif

/*
 * Hardcoded flash setup:
 * Flash 0 is a non-CFI AMD AM29LV800BB flash.
 */
ulong board_flash_get_legacy(ulong base, int banknum, flash_info_t *info)
{
	info->portwidth = FLASH_CFI_16BIT;
	info->chipwidth = FLASH_CFI_BY16;
	info->interface = FLASH_CFI_X16;
	return 1;
}
